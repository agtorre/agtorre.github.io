<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Versioning on Aaron Torres </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://www.aaron-torres.com/tags/versioning/</link>
    <language>en-us</language>
    
    
    <updated>Tue, 17 May 2016 00:00:00 UTC</updated>
    
    <item>
      <title>Go API Versioning with Gorilla Mux</title>
      <link>http://www.aaron-torres.com/post/api-versioning-gorilla-mux/</link>
      <pubDate>Tue, 17 May 2016 00:00:00 UTC</pubDate>
      
      <guid>http://www.aaron-torres.com/post/api-versioning-gorilla-mux/</guid>
      <description>

&lt;h3 id=&#34;code-based-versioning&#34;&gt;Code-Based Versioning&lt;/h3&gt;

&lt;p&gt;Recently I had a problem where I needed to implement API versioning in code. The versions would share the vast majority of routes/handlers and I found that I wanted to re-use the base routes and modifying them slightly between versions. I imagined using &lt;a href=&#34;http://www.gorillatoolkit.org/pkg/mux&#34;&gt;Gorilla mux router&lt;/a&gt; as the base with all the routes and then creating a new router for v1, v2, etc that would &amp;lsquo;inherit&amp;rsquo; the base routes and only modify a few. That would maximize code-reuse as I&amp;rsquo;d only have to modify the latest route in one place for many versions to receive the benefit.&lt;/p&gt;

&lt;p&gt;I searched around Google, Stack Overflow, and the Gorilla mux documentation about attaching a subrouter to a route and similar terms, but I struggled to find a working solution. I found a few useful posts and here&amp;rsquo;s the result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
        &amp;quot;fmt&amp;quot;
        &amp;quot;net/http&amp;quot;

        &amp;quot;github.com/gorilla/mux&amp;quot;
)

// AnotherHandlerLatest is the newest version of AnotherHandler
func AnotherHandlerLatest(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &amp;quot;hello from AnotherHandlerLatest.&amp;quot;)
}

// ExampleHandlerLatest is the newest version of ExampleHandler
func ExampleHandlerLatest(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &amp;quot;hello from ExampleHandlerLatest.&amp;quot;)
}

// ExampleHandlerV1 is a v1-compatible version of ExampleHandler
func ExampleHandlerV1(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &amp;quot;Hello from ExampleHandlerv1.&amp;quot;)
}

// AddV1Routes takes a router or subrouter and adds all the v1
// routes to it
func AddV1Routes(r *mux.Router) {
        r.HandleFunc(&amp;quot;/example&amp;quot;, ExampleHandlerV1)
        AddRoutes(r)
}

// AddV2Routes takes a router or subrouter and adds all the v2
// routes to it, note that these should probably match
// AddRoutes(r *muxRouter) alternatively you can do
// var AddV2Routes = AddRoutes
func AddV2Routes(r *mux.Router) {
        AddRoutes(r)
}

// AddRoutes takes a router or subrouter and adds all the latest
// routes to it
func AddRoutes(r *mux.Router) {
        r.HandleFunc(&amp;quot;/example&amp;quot;, ExampleHandlerLatest)
        r.HandleFunc(&amp;quot;/example2&amp;quot;, AnotherHandlerLatest)
}

func main() {
        router := mux.NewRouter()

        // latest
        AddRoutes(router)

        // v1
        AddV1Routes(router.PathPrefix(&amp;quot;/v1&amp;quot;).Subrouter())

        // v2
        AddV2Routes(router.PathPrefix(&amp;quot;/v2&amp;quot;).Subrouter())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The end result of this is that /example and /v2/example point at the same handler, but /v1/example points at a different handler. When a new version is created, I rename HandlerLatest to HandlerVn where n is the previous newest version. I add it to the AddVnRoutes, create an AddVn+1Routes and new version is made! I can easily deprecate older versions (and their associated handlers) as needed.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
